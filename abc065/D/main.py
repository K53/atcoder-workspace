#!/usr/bin/env python3
import sys
import heapq
class Prim():
    def __init__(self, N: int) -> None:
        # self.minimumG = [[] for _ in range(N)] # 全域最小木自体が欲しい場合にはこれを有効にする。(未実装 -> クラスカル法推奨)
        self.G = [[] for _ in range(N)]
        self.seen = [[] for _ in range(N)]
        self.minimunCost = 0
        return
    
    def addEdge(self, a: int, b: int, cost: int):
        self.G[a].append((cost, b))
        self.G[b].append((cost, a))
        return

    def build(self):
        hq = []
        heapq.heapify(hq)
        start_node = 0
        heapq.heappush(hq, (0, start_node))
        while hq:
            min_cost, now = heapq.heappop(hq)
            if self.seen[now]:
                continue
            self.seen[now] = 1
            self.minimunCost += min_cost
            for cost, next in self.G[now]:
                if self.seen[next]:
                    continue
                heapq.heappush(hq, (cost, next))
        return self.minimunCost
        

def solve(N: int, x: "List[int]", y: "List[int]"):
    l = [(x[i], y[i], i) for i in range(N)]
    sx = sorted(l, key=lambda a:a[0])
    sy = sorted(l, key=lambda a:a[1])
    # print(sx)
    # print(sy)
    p = Prim(N)
    for i in range(N - 1):
        xx1, yy1, idx1 = sx[i] 
        xx2, yy2, idx2 = sx[i + 1] 
        c = min(abs(xx1 - xx2), abs(yy1 - yy2))
        p.addEdge(idx1, idx2, c)

        xx1, yy1, idx1 = sy[i] 
        xx2, yy2, idx2 = sy[i + 1] 
        c = min(abs(xx1 - xx2), abs(yy1 - yy2))
        p.addEdge(idx1, idx2, c)
    p.build()
    print(p.minimunCost)


    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    x = [int()] * (N)  # type: "List[int]"
    y = [int()] * (N)  # type: "List[int]"
    for i in range(N):
        x[i] = int(next(tokens))
        y[i] = int(next(tokens))
    solve(N, x, y)

if __name__ == '__main__':
    main()
