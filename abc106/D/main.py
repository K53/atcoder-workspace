#!/usr/bin/env python3
import sys


def solve(N: int, M: int, Q: int, L: "List[int]", R: "List[int]", p: "List[int]", q: "List[int]"):
    class MatrixAccumulates:
        def __init__(self, H: int, W: int) -> None:
            self.H, self.W = H, W
            self.LL = [[0] * W for _ in range(H)]
            self.S = []
        
        def add(self, y, x, val):
            self.LL[y][x] += val
            return

        def setList(self, LL: "List[List[int]]"):
            self.LL = LL
            return

        def build(self, index1: bool = False):
            if index1:
                self.S = [[0] * self.W for _ in range(self.H)]
                #ヨコに累積和
                for i in range(self.H):
                    for j in range(self.W):
                        if i == 0:
                            self.S[i][j] = self.LL[i][j]
                        else:
                            self.S[i][j] = self.S[i-1][j] + self.LL[i][j]
                #タテに累積和
                for i in range(self.H):
                    for j in range(self.W):
                        if j == 0:
                            self.S[i][j] = self.S[i][j]
                        else:
                            self.S[i][j] = self.S[i][j-1] + self.S[i][j]
            else:
                # 累積和(DPで算出)
                # 0行目/0列目に0を挿入した二次元累積和Sを得る。
                self.S = [[0] * (self.W + 1) for _ in range(self.H + 1)]
                for i in range(self.H):
                    for j in range(self.W):
                        self.S[i + 1][j + 1] = self.S[i + 1][j] + self.S[i][j + 1] - self.S[i][j] + self.LL[i][j]
            return
        
        def getArea(self, excY, incY, excX, incX) -> int:
            '''
            exampl) excX = 1, excY = 0, incX = 3, incY = 2
                    excX  incX
                    0  1  2  3
            excY 0  x  x  x  x
                 1  x  x  o  o
            incY 2  x  x  o  o
            '''
            areaAccumulate = self.S[incY][incX] - self.S[excY][incX] - self.S[incY][excX] + self.S[excY][excX]
            return areaAccumulate
        
        def printS(self) -> int:
            for i in range(self.H):
                print(self.S[i])
            return
    ma = MatrixAccumulates(N + 1, N + 1)
    for ll, rr in zip(L, R):
        ma.add(ll, rr, 1)
    ma.build()
    for ll, rr in zip(p, q):
        print(ma.getArea(ll, rr + 1, ll, rr + 1))
    return


# Generated by 2.6.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    L = [int()] * (M)  # type: "List[int]"
    R = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        L[i] = int(next(tokens))
        R[i] = int(next(tokens))
    p = [int()] * (Q)  # type: "List[int]"
    q = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        p[i] = int(next(tokens))
        q[i] = int(next(tokens))
    solve(N, M, Q, L, R, p, q)

if __name__ == '__main__':
    main()
