#!/usr/bin/env python3
from math import sin, cos, radians
class AffineMap():
    origin = [
        [1, 0, 0], 
        [0, 1, 0], 
        [0, 0, 1]
    ]
    @staticmethod
    def generateOrigin():
        """
        原点座標を取得する。
        """
        return AffineMap.origin[:]

    @staticmethod
    def _matmul3(a: "list[list[int]]", b: "list[list[int]]"):
        res = [
            [0, 0, 0], 
            [0, 0, 0], 
            [0, 0, 0]
        ]
        for i in range(3):
            for k in range(3):
                aik = a[i][k]
                for j in range(3):
                    res[i][j] += b[k][j] * aik
        return res

    @staticmethod
    def shift(a: "list[int]", shift_x: int = 0, shift_y: int = 0):
        b = [
            [1, 0, shift_x], 
            [0, 1, shift_y], 
            [0, 0, 1]
        ]
        return AffineMap._matmul3(b, a)

    @staticmethod
    def expand(a: "list[int]", ratio_x: int = 1, ratio_y: int = 1):
        b = [
            [ratio_x, 0, 0], 
            [0, ratio_y, 0], 
            [0, 0, 1]
        ]
        return AffineMap._matmul3(b, a)

    @staticmethod
    def rotate(a: "list[int]", center_x: int = 0, center_y: int = 0, digree: int = 0):
        """
        回転
        degree度(度数法)回転する。
        """
        if digree == 90:
            b = [
                [0, -1, center_x + center_y], 
                [1, 0, center_y - center_x], 
                [0, 0, 1]
            ]
        elif digree == -90:
            b = [
                [0, 1, center_x - center_y], 
                [-1, 0, center_y + center_x], 
                [0, 0, 1]
            ]
        else:
            digree = radians(digree)
            b = [
                [cos(digree), -sin(digree), center_x - center_x * cos(digree) + center_y * sin(digree)], 
                [sin(digree), cos(digree), center_y - center_x * sin(digree) - center_y * cos(digree)], 
                [0, 0, 1]
            ]
        return AffineMap._matmul3(b, a)
    
    @staticmethod
    def x_symmetrical_move(a: "list[int]", p: int):
        """
        対称移動
        直線 x = p で対称移動する。
        """
        b = [
            [-1, 0, 2 * p], 
            [0, 1, 0], 
            [0, 0, 1]
        ]
        return AffineMap._matmul3(b, a)

    @staticmethod
    def y_symmetrical_move(a: "list[int]", p: int):
        """
        対称移動
        直線 y = p で対称移動する。
        """
        b = [
            [1, 0, 0], 
            [0, -1, 2 * p], 
            [0, 0, 1]
        ]
        return AffineMap._matmul3(b, a)

    @staticmethod
    def get(a: "list[list[int]]", x, y):
        """
        点(x, y)を変換行列aを用いて変換後の頂点の座標を返す。
        """
        a0, a1, a2 = a
        x, y = a0[0] * x + a0[1] * y + a0[2], a1[0] * x + a1[1] * y + a1[2]
        return x, y

# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    N = int(input())
    x0, y0 = map(int, input().split())
    xh, yh = map(int, input().split())
    xc = (x0 + xh) / 2
    yc = (y0 + yh) / 2
    matrix = AffineMap.generateOrigin()
    matrix = AffineMap.rotate(matrix, xc, yc, 360 / N)
    a, b = AffineMap.get(matrix, x0, y0)
    print(a, b)

if __name__ == '__main__':
    main()
