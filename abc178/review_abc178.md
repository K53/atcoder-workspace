# A

## ビット反転

### 1) ビットを反転させる。

x = 0なら1に、x = 1なら0にしたい時。
単純に反転させる`~`は使用できないことに注意。

#### ~ : ビット反転

`~x` = `-(x + 1)`となる。これはxを2の補数形式とみなして反転した結果が返るため。

#### ^ : 排他的論理和 (XOR)

```
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 1 = 0
```

0は影響を与えず、1はビットを反転させることからビットを反転させるには`x ^ 1`

### 2) 特定のビットを反転させる。

N桁のビット列のうち特定のk番目のビットのみを反転させたい時、ビットシフトと組み合わせて`x ^ (1 << k)`で実現できる。

https://yottagin.com/?p=5261

# C

## 包除定理

一般に積集合(A∩B)の方が和集合(A∪B)より求めやすい。そのため以下の様にして積集合から求める。
> A∪B = A + B - A∩B

https://compro.tsutaj.com//archive/181015_incexc.pdf

# D

動的計画法(DP)の問題。

n = Sとした時、和がnとなる数列の数をdp[n]個と表すと、数列の末尾が3となる場合の数列はdp[n-3]個となる。

```
{ _, _, ・・・ _, 3 }
  ←- dp[n-3] -→
```

同様に末尾が4となる数列はdp[n-4]個、5となるのはdp[n-5]・・・末尾がnとなるのはdp[0]=1となる。
すなわち、`dp[n] = dp[n-3] + dp[n-4] + ・・・ + dp[0]`となる。
ここでこの数列(級数)を漸化式で表すことを考える。

`dp[n-1] = dp[n-4] + ・・・ + dp[0]`であることから上記の式に適応し、

`dp[n] = dp[n-3] + dp[n-1]`となる。

