#!/usr/bin/env python3
import sys

def eratosthenes(n):
    numbers = [-1] * (n+1)
    numbers[0] = -1
    numbers[1] = -1
    for i in range(2,n+1):
        if numbers[i] != -1:
            continue
        for j in range(i,n+1,i):
            if numbers[j] == -1:
                numbers[j] = i
    return numbers
 
 
def fastFactor(n,e = None): # エラトステネスの篩の過程のリストを用いるのでNのリストを必要とする
    if e == None:# 篩のデータを構築済みであれば早い
        e = eratosthenes(n)
    result = []
    while n != 1:
        d = e[n]
        result.append(d)
        n //= d
    return result

def solve(N: int, M: int, A: "List[int]"):
    print(fastFactor(12))
    # def getPrimeLists(limit: int):
    #     primes = [] # 素数リスト
    #     isPrime = [True] * (limit + 1) # 素数かどうかのフラグ
    #     isPrime[0] = False
    #     isPrime[1] = False
        
    #     for p in range(limit + 1):  # p : 判定対象の数
    #         if not isPrime[p]:
    #             continue
    #         for aa in A:
    #             if aa % p == 0:
    #                 break
    #         else:
    #             continue
    #         # pが素数のためそれ以降に出現するpの倍数を除外する。
    #         # なお、ループはp始まりでも良いが、p * _ のかける側はすでに同じ処理で弾かれているはずのため無駄。
    #         for i in range(p * p, limit + 1, p):
    #             isPrime[i] = False
    #     return primes
    # # print(getPrimeLists(10 ** 5))



    # l = getPrimeLists(10 ** 5)
    # print(l)
    # limit = M
    # primes = [] # 素数リスト
    # isPrime = [True] * (limit + 1) # 素数かどうかのフラグ
    # isPrime[0] = False
    # isPrime[1] = False
    # for p in l:
    #     if not isPrime[p]:
    #         continue
    #     primes.append(p)
    #     # pが素数のためそれ以降に出現するpの倍数を除外する。
    #     # なお、ループはp始まりでも良いが、p * _ のかける側はすでに同じ処理で弾かれているはずのため無駄。
    #     for i in range(p * p, limit + 1, p):
    #         isPrime[i] = False
    # ss = set(l)
    # ans = [1]
    # for i in range(len(isPrime)):
    #     if isPrime[i] and not i in ss:
    #         ans.append(i)

    # print(len(ans))
    # print(*ans, sep="\n")
# Generated by 2.8.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    A = [int(next(tokens)) for _ in range(N)]  # type: "List[int]"
    solve(N, M, A)

if __name__ == '__main__':
    main()
