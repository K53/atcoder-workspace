#!/usr/bin/env python3
import sys

def solve(N: int, M: int, A: "List[int]", B: "List[int]", C: "List[int]"):
    import copy
    import heapq
    INF = 10 ** 16       # *2
    def dijkstra(edges: "List[List[(cost, to)]]", start_node: int) -> list:
        hq = []
        heapq.heapify(hq)
        # Set start info
        dist = [INF] * len(edges)
        heapq.heappush(hq, (0, start_node))
        dist[start_node] = 0            # *1
        # dijkstra
        while hq:
            min_cost, now = heapq.heappop(hq)
            if min_cost > dist[now]:
                continue
            for cost, next in edges[now]:
                if dist[next] > dist[now] + cost:
                    dist[next] = dist[now] + cost
                    heapq.heappush(hq, (dist[next], next))
        return dist
    all = [[] for _ in range(N)]
    for i in range(M):
        all[A[i] - 1].append((C[i], B[i] - 1))
    # print(all)

    ans = 0
    if M == 0:
        print(0)
        return
    l = []
    for aa, bb, cc in zip(A, B, C):
        l.append((max(aa - 1, bb - 1), aa - 1, bb - 1, cc))
    l.sort()
    nodes = [[] for _ in range(N)]
    nowL = 0
    for k in range(N):
        for now in range(nowL, M):
            if l[now][0] <= k:
                _, aa, bb, cc = l[now]
                nodes[aa].append((cc, bb))
            else:
                nowL = now
                break
        nodes[k].extend(all[k])
        for s in range(N):
            if s > k:
                cnodes = copy.deepcopy(nodes)
                cnodes[s].extend(all[s])
            # for i in l:
            #     d, aa, bb, cc = l[i]
            #     if d <= k or aa in [s, ]:
            #         cnodes[aa].append((cc, bb))
            # for t in range(N):
                # if s == t:
                #     continue
                dist = dijkstra(cnodes, s)
                # print(s, cnodes, dist)
            else:
                dist = dijkstra(nodes, s)
                # print(s, nodes, dist)
            for w in dist:
                if w != INF:
                    ans += w
        # print(ans)
            # else:
            #     for cc, i in all[s]:
            #         if i == t:
            #             ans += cc
            #             print(cc)



    print(ans)
    return


# Generated by 2.5.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    A = [int()] * (M)  # type: "List[int]"
    B = [int()] * (M)  # type: "List[int]"
    C = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        A[i] = int(next(tokens))
        B[i] = int(next(tokens))
        C[i] = int(next(tokens))
    solve(N, M, A, B, C)

if __name__ == '__main__':
    main()
