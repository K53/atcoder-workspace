#!/usr/bin/env python3
import sys

def solve(N: int, x: "List[int]", y: "List[int]"):
    # 最小にしたい関数f (例: 10/√(k + 1) + k)
    def fy(fixed_x: int, k: float or int) -> float:
        m = 0
        for xx, yy in zip(x, y):
            m = max(((xx - fixed_x) ** 2 + (yy - k) ** 2) ** 0.5, m)
        return m
        
    def ternarySearchy(fixed_x: float, l: float, r: float, accept_range: int = 2) -> tuple:
        """
        - l : 定義域(l ≦ x ≦ r)の左端
        - r : 定義域(l ≦ x ≦ r)の右端
        - accept_range : 探索で絞った後の範囲
        三分探索を行い、最小値を取る値の範囲l ~ rを返却する。
        """
        # 範囲が accept_range 以下に絞られるまで回す。
        while r - l > accept_range:
            # オーバーフローしないための三等分点を置く
            mid1 = l + (r - l) / 3 # 探索する値の定義域が整数の場合は // として割り切る。
            mid2 = r - (r - l) / 3 # 探索する値の定義域が整数の場合は // として割り切る。
            if fy(fixed_x, mid1) < fy(fixed_x, mid2):
                r = mid2
            else:
                l = mid1
        return l, r

    # 最小にしたい関数f (例: 10/√(k + 1) + k)
    def fx(k: float or int) -> float:
        l, r = ternarySearchy(k, 0, 1000 + 1, pow(10, -7))
        return fy(k, l)
        
    def ternarySearchx(l: float, r: float, accept_range: int = 2) -> tuple:
        """
        - l : 定義域(l ≦ x ≦ r)の左端
        - r : 定義域(l ≦ x ≦ r)の右端
        - accept_range : 探索で絞った後の範囲
        三分探索を行い、最小値を取る値の範囲l ~ rを返却する。
        """
        # 範囲が accept_range 以下に絞られるまで回す。
        while r - l > accept_range:
            # オーバーフローしないための三等分点を置く
            mid1 = l + (r - l) / 3 # 探索する値の定義域が整数の場合は // として割り切る。
            mid2 = r - (r - l) / 3 # 探索する値の定義域が整数の場合は // として割り切る。
            if fx(mid1) < fx(mid2):
                r = mid2
            else:
                l = mid1
        return (l, r)

    l, r = ternarySearchx(0, 1000 + 1, pow(10, -7))
    print(fx(l))
    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    x = [int()] * (N)  # type: "List[int]"
    y = [int()] * (N)  # type: "List[int]"
    for i in range(N):
        x[i] = int(next(tokens))
        y[i] = int(next(tokens))
    solve(N, x, y)

if __name__ == '__main__':
    main()
