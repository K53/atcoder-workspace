#!/usr/bin/env python3
import sys


def solve(N: int, M: int, K: int, A: "List[int]", B: "List[int]", C: "List[int]", D: "List[int]"):
    class UnionFind():
        def __init__(self, n):
            self.n = n
            self.parents = [-1] * n # 根は自分を含めて下に何個の要素がぶら下がっているかが負の数で表される。
            
        def find(self, x):
            if self.parents[x] < 0:
                return x
            else:
                self.parents[x] = self.find(self.parents[x])
                return self.parents[x]
        
        def union(self, x, y):
            x = self.find(x)
            y = self.find(y)
            
            if x == y:
                return
            
            if self.parents[x] > self.parents[y]:
                x, y = y, x
            
            self.parents[x] += self.parents[y]
            self.parents[y] = x
        
        # 要素xの属する集合の要素数を返す
        def size(self, x):
            return -self.parents[self.find(x)]
        
        # 要素x,yが同じ集合かを返す
        def same(self, x, y):
            return self.find(x) == self.find(y)
        
        def members(self, x):
            root = self.find(x)
            return [i for i in range(self.n) if self.find(i) == root]
        
        def roots(self):
            return [i for i, x in enumerate(self.parents) if x < 0]

        # 集合の数を返す
        def group_count(self):
            return len(self.roots())
        
        def all_group_members(self):
            return {r: self.members(r) for r in self.roots()}
        
        def __str__(self):
            return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())
    uf = UnionFind(N)
    friend = [0] * N
    block = [[] for _ in range(N)]
    for aa, bb in zip(A, B):
        uf.union(aa - 1, bb - 1)
        friend[aa - 1] += 1
        friend[bb - 1] += 1
    for cc, dd in zip(C, D):
        block[cc - 1].append(dd - 1)
        block[dd - 1].append(cc - 1)
    ans = []
    for i in range(N):
        q = uf.size(i) - friend[i] - 1 # 自分1
        for b in block[i]:
            if uf.same(i, b):
                q -= 1
        ans.append(q)
    print(*ans, sep=" ")
    return


# Generated by 2.6.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    A = [int()] * (M)  # type: "List[int]"
    B = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        A[i] = int(next(tokens))
        B[i] = int(next(tokens))
    C = [int()] * (K)  # type: "List[int]"
    D = [int()] * (K)  # type: "List[int]"
    for i in range(K):
        C[i] = int(next(tokens))
        D[i] = int(next(tokens))
    solve(N, M, K, A, B, C, D)

if __name__ == '__main__':
    main()
