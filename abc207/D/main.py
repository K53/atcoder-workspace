#!/usr/bin/env python3
import copy

YES = "Yes"  # type: str
NO = "No"  # type: str

three = (3, 3)
one = (3, 1)
def mul(S, sizeS, T, sizeT):
    ''' 行列積 S @ T を計算する
    S, T: 1次元行列
    sizeS, sizeT: [row数, col数]

    Sc == Tr 必須

    Returns: [Sr, Tc]の1次元行列
    '''
    Sr, Sc, Tr, Tc = *sizeS, *sizeT
    N = Sr * Tc
    ret = [0] * (N)
    for i in range(N):
        x, y = divmod(i, Tc)
        L = S[Sc * x: Sc * (x + 1)]
        R = [T[Tc * j + y] for j in range(Tr)]
        tmp = sum(a * b for a, b in zip(L, R))
        ret[i] = tmp
    return ret

def move(x, y):
    return [1, 0, x, 0, 1, y, 0, 0, 1]

def turn(k):
    if k == 0:
        c, s = 1, 0
    elif k == 90:
        c, s = 0, 1
    elif k == 180:
        c, s = -1, 0
    else:
        c, s = 0, -1
    return [c, -s, 0, s, c, 0, 0, 0, 1]


# Generated by 2.5.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    N = int(input())
    S, T = [], []
    for _ in range(N):
        S.append(list(map(int, input().split())) + [1])
    for _ in range(N):
        T.append(list(map(int, input().split())) + [1])
    
    # a = move(9, 10)
    a = turn(90)
    # print((mul(a, three, S[0], one)))

    for i in [0, 90, 180, 270]:
        Si = []
        a = turn(i)
        for nn in range(N):
            Si.append(mul(a, three, S[nn], one))
            # print(i, Si)
        for sss in Si:
            if not sss in T:
                break
        else:
            print(YES)
            return
        for dx in range(-10, 11):
            Sdx = copy.deepcopy(Si)
            m = move(dx, 0)
            for nn in range(N):
                Sdx[nn] = mul(m, three, Sdx[nn], one)
            # print(i, dx, Sdx)
            for sss in Sdx:
                if not sss in T:
                    break
            else:
                print(YES)
                return
            for dy in range(-10, 11):
                Sdy = copy.deepcopy(Sdx)
                m = move(0, dy)
                for nn in range(N):
                    Sdy[nn] = mul(m, three, Sdy[nn], one)
                # print(i, dx, dy, Sdy)
                for sss in Sdy:
                    if not sss in T:
                        break
                else:
                    print(YES)
                    return
    print(NO)
                

if __name__ == '__main__':
    main()
