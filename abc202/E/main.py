#!/usr/bin/env python3
import sys


def solve(N: int, P: "List[int]", Q: int, U: "List[int]", D: "List[int]"):
    import queue
    INF = 10 ** 18
    def bfs(edges: "List[to]", start_node: int) -> list:
        q = queue.Queue()
        dist = [INF] * len(edges)
        q.put(start_node)
        dist[start_node] = 0
        while not q.empty():
            now = q.get()
            for next in edges[now]:
                if dist[next] != INF:
                    continue
                q.put(next)
                dist[next] = dist[now] + 1
        return dist
    def bfs2(edges: "List[to]", start_node: int, rest:int) -> list:
        q = queue.Queue()
        dist = [INF] * len(edges)
        q.put(start_node)
        dist[start_node] = 0
        ans = 0
        while not q.empty():
            now = q.get()
            for next in edges[now]:
                if dist[next] != INF:
                    continue
                q.put(next)
                dist[next] = dist[now] + 1
                if dist[next] == rest:
                    ans += 1
        return ans
    # from collections import defaultdict
    # class UnionFind():
    #     def __init__(self, n):
    #         self.n = n
    #         self.parents = [-1] * n

    #     def find(self, x):
    #         if self.parents[x] < 0:
    #             return x
    #         else:
    #             self.parents[x] = self.find(self.parents[x])
    #             return self.parents[x]

    #     def union(self, x, y):
    #         x = self.find(x)
    #         y = self.find(y)

    #         if x == y:
    #             return

    #         if self.parents[x] > self.parents[y]:
    #             x, y = y, x

    #         self.parents[x] += self.parents[y]
    #         self.parents[y] = x

    #     def size(self, x):
    #         return -self.parents[self.find(x)]

    #     def same(self, x, y):
    #         return self.find(x) == self.find(y)

    #     def members(self, x):
    #         root = self.find(x)
    #         return [i for i in range(self.n) if self.find(i) == root]

    #     def roots(self):
    #         return [i for i, x in enumerate(self.parents) if x < 0]

    #     def group_count(self):
    #         return len(self.roots())

    #     def all_group_members(self):
    #         group_members = defaultdict(list)
    #         for member in range(self.n):
    #             group_members[self.find(member)].append(member)
    #         return group_members

    #     def __str__(self):
    #         return '\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())

    
    edges = [[] for _ in range(N)]
    for i in range(N - 1):
        edges[P[i] - 1].append(i + 1)
    # print(edges)
    d = bfs(edges, 0)
    # print(d)
    for qq in range(Q):
        rest = D[qq] - d[U[qq] - 1]
        if rest < 0:
            print(0)
            continue
        if rest == 0:
            print(1)
            continue
        # print(rest)
        dd = bfs2(edges, U[qq] - 1, rest)
        print(dd)
        # uf = UnionFind(N)
        # print(uf.parents)
        # print(rest)
        # for e in edges[]:
        # uf.parents()


    return


# Generated by 2.3.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    P = [int(next(tokens)) for _ in range(N - 2 + 1)]  # type: "List[int]"
    Q = int(next(tokens))  # type: int
    U = [int()] * (Q)  # type: "List[int]"
    D = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        U[i] = int(next(tokens))
        D[i] = int(next(tokens))
    solve(N, P, Q, U, D)

if __name__ == '__main__':
    main()
