#!/usr/bin/env python3
import sys

def solve(N: int, K: int, A: "List[List[int]]"):
    class MatrixAccumulates:
        def __init__(self, H: int, W: int) -> None:
            self.H, self.W = H, W
            self.LL = [[0] * W for _ in range(H)]
            self.S = []
        
        def add(self, y, x, val):
            self.LL[y][x] += val
            return

        def setList(self, LL: "List[List[int]]"):
            for i in range(self.H):
                for j in range(self.W):
                    self.LL = LL[i][j]
            return

        def build(self, index1: bool = False):
            if index1:
                self.S = [[0] * self.W for _ in range(self.H)]
                #ヨコに累積和
                for i in range(self.H):
                    for j in range(self.W):
                        if i == 0:
                            self.S[i][j] = self.LL[i][j]
                        else:
                            self.S[i][j] = self.S[i-1][j] + self.LL[i][j]
                #タテに累積和
                for i in range(self.H):
                    for j in range(self.W):
                        if j == 0:
                            self.S[i][j] = self.S[i][j]
                        else:
                            self.S[i][j] = self.S[i][j-1] + self.S[i][j]
            else:
                # 累積和(DPで算出)
                # 0行目/0列目に0を挿入した二次元累積和Sを得る。
                self.S = [[0] * (self.W + 1) for _ in range(self.H + 1)]
                for i in range(self.H):
                    for j in range(self.W):
                        self.S[i + 1][j + 1] = self.S[i + 1][j] + self.S[i][j + 1] - self.S[i][j] + self.LL[i][j]
            return
        
        def getArea(self, excY, incY, excX, incX) -> int:
            '''
            exampl) excX = 1, excY = 0, incX = 3, incY = 2
                    excX  incX
                    0  1  2  3
            excY 0  x  x  x  x
                 1  x  x  o  o
            incY 2  x  x  o  o
            '''
            areaAccumulate = self.S[incY][incX] - self.S[excY][incX] - self.S[incY][excX] + self.S[excY][excX]
            # print(self.S[incY][incX], self.S[excY][incX], self.S[incY][excX], self.S[excY][excX])
            return areaAccumulate
        
        def printS(self) -> int:
            for i in range(self.H):
                print(self.S[i])
            return

    # True ------ ok | ng ---- False
    # 全ての区画の中央値をk以上にできるか？1つでもできない区画があるとkは最小値として選択できなくなるのでFalse
    def is_ok(k: int):
        ma = MatrixAccumulates(N, N)
        for i in range(N):
            for j in range(N):
                if A[i][j] >= k:
                    ma.add(i, j, 1)
        ma.build()
        # for i in range(N):
        #     print(ma.LL[i])
        # for i in range(N + 1):
        #     print(ma.S[i])
        for ex in range(N - K + 1):
            for ey in range(N - K + 1):
                tot = ma.getArea(ey, ey + K, ex, ex + K)
                if tot < (K ** 2 // 2 + 1):
                    return False
        return True

    def binSearch(ok: int, ng: int):
        # print(ok, ng)              # はじめの2値の状態
        while abs(ok - ng) > 1:     # 終了条件（差が1となり境界を見つけた時)
            mid = (ok + ng) // 2
            # print("target > ", mid)
            result = is_ok(mid)
            # print(result)
            if result:
                ok = mid            # midが条件を満たすならmidまではokなのでokの方を真ん中まで持っていく
            else:
                ng = mid            # midが条件を満たさないならmidまではngなのでngの方を真ん中まで持っていく
            # print(ok, ng)          # 半分に切り分ける毎の2値の状態
        return ok
    a = binSearch(-1, 10 ** 9 + 1)
    print(a)
    return


# Generated by 2.3.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    A = [[int(next(tokens)) for _ in range(N)] for _ in range(N)]  # type: "List[List[int]]"
    solve(N, K, A)

if __name__ == '__main__':
    main()
