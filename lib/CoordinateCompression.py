# ------------------------------------------------------------------------------
#     座標圧縮
# ------------------------------------------------------------------------------
# 解説
# 1. 重複を排除後にソート。
# 2. 小さい要素valから順にナンバリング(listのindexを適用)。→ 0-index
# 3. 元の要素がどの圧縮後のindexに対応するかの辞書に変更 → 1を加算して1-index。
#
# - 出現しうる要素の範囲が大きく単純にバケット法が利用できないが、1テストケースあたりの要素数の最大数は少ない場合に利用可能。
# 
# Order
#   O(len(L))
#
# verify
# - https://atcoder.jp/contests/abc213/tasks/abc213_c
# - https://atcoder.jp/contests/abc036/tasks/abc036_c
# ------------------------------------------------------------------------------
# L = [9, 5, 2, 6]
L = list(map(int, "198495780 28463047 859606611 212983738 946249513 789612890 782044670 700201033 367981604 302538501".split()))
d = {val : index + 1 for index, val in enumerate(sorted(list(set(L))))}
print(d)
"-> {2: 1, 5: 2, 6: 3, 9: 4}"
a = []
for i in L:
    a.append(d[i])
print(a)
s = 0
s += (2 ** 9 - 1)
s += (2 ** 7 - 1) * (2 ** 1)
s += (2 ** 1 - 1) * (2 ** 6)
s += (2 ** 6 - 1)
print(s % 998244353)


# ans = 0
# for i in L:
#     p, q = 0,0
#     for j in L[(i + 1):]:
#         if i <= j:
#             p += 1
#         else:
#             q += 1
#     ans += ((2 ** p - 1) * 2 ** q) % 998244353
# print(ans % 998244353)
    
