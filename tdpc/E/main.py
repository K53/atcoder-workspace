#!/usr/bin/env python3
import sys

MOD = 1000000007  # type: int

def solve(D: int, N: str):
    S = str(N)
    dp = [[[0] * D for _ in range(2)] for _ in range(10 ** 5 + 1)]
    dp[0][0][0] = 1

    for dig in range(len(S)):
        nextDigNumMax = int(S[dig])
        for smaller in range(2):
            for mo in range(D):
                ceil = 9 if smaller else nextDigNumMax
                for num in range(ceil + 1):
                    next_smaller = 0
                    if smaller == 1 or num < ceil:
                        next_smaller = 1
                    dp[dig + 1][next_smaller][(mo + num) % D] += dp[dig][smaller][mo]
                    dp[dig + 1][next_smaller][(mo + num) % D] %= MOD
    print(dp[len(S)][0][0] + dp[len(S)][1][0] - 1)
            
    # # dp[dig][smaller][mo] := 先頭からdig桁決定した時に和の余りがmoのものの個数。smaller = Falseでは上限に達しているということ。
    # dp = [[[0] * D for _ in range(2)] for _ in range(10 ** 5 + 1)]
    # dp[0][0][0] = 1

    # for dig in range(len(S)):
    #     for mo in range(D):
    #         # dig桁目はNの上限でなく、dig+1桁目はなんでも良い時。
    #         for k in range(10):
    #             dp[dig + 1][1][(mo + k) % D] += dp[dig][1][mo]
    #             dp[dig + 1][1][(mo + k) % D] %= MOD
    #         # dig桁目はNの上限であり、dig+1桁目はNの上限より小さい時。
    #         for k in range(int(S[dig])):
    #             dp[dig + 1][1][(mo + k) % D] += dp[dig][0][mo]
    #             dp[dig + 1][1][(mo + k) % D] %= MOD
    #         # dig桁目はNの上限であり、dig+1桁目もNの上限である時。
    #         dp[dig + 1][0][(mo + int(S[dig])) % D] += dp[dig][0][mo]
    #         dp[dig + 1][0][(mo + int(S[dig])) % D] %= MOD

    # ans = dp[len(S)][0][0] +  dp[len(S)][1][0] - 1
    # print(ans)

    # # for dig in range(len(S)):
    # #     print(dp[dig][0])

    # # print("-------")
    # # for dig in range(len(S)):
    # #     print(dp[dig][1])

    # return


# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    D = int(next(tokens))  # type: int
    N = next(tokens)  # type: str
    solve(D, N)

if __name__ == '__main__':
    main()
